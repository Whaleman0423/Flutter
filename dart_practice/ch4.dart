// Chapter 4 運算子

/* 
運算子存在優先順序，
就像在數學中常說的，先乘除後加減一樣。

在運算子表中，在同一列中優先順序依次降低，
即第一行優先順序最高，最後一行優先順序最低。

在同一行中從左到右優先順序依次降低，
即左邊的優先順序最高，最右端的優先順序最低。
*/

// 常見的算數運算子
// void main() {
//   // 加號運算
//   print('1 + 3 = ${1 + 3}');

//   // 減號運算
//   print('8 - 6 = ${8 - 6}');

//   // 負號運算
//   var a = 6;
//   print('-a = ${-a}');

//   // 對運算式符號反轉
//   print('-(-a) = ${-(-a)}');

//   // 乘號運算
//   print('6 * 7 = ${6 * 7}');

//   // 除號運算
//   print('8 / 2 = ${8 / 2}');

//   // 除並取整數運算
//   print('9 ~/ 2 = ${9 ~/ 2}');

//   // 除並取餘數運算
//   print('9 % 2 = ${9 % 2}');
// }

// 自動增加 & 自動減少
// void main() {
//   var a = 10;
//   var b = 20;
//   var c = 30;
//   var d = 40;
//   var e, f, g, h;

//   // a 先自加再設定值給 e
//   e = ++a;
//   print('e : $e, a : $a');

//   // b 先設定值給 f 再自加
//   f = b++;
//   print('f : $f, b : $b');

//   // c 先自減再設定值給 g
//   g = --c;
//   print('g : $g, c : $c');

//   // d 先設定值給 h 再自減
//   h = d--;
//   print('h : $h, d : $d');
// }

// 4.2 關係運算子
/*
關聯運算式 屬於布林運算式，所以它們的返回值均為布林值，即 true 或 false。

要測試兩個物件是否表示同樣的值，例如【數值】、【布林值】或【字串值】等，
需使用 == 運算子。

有時需要知道兩個物件是否是完全相同的物件，需改用 identical() 函數。

(1) 判斷 x 或 y 是否為 null 的情況 : 
若兩個均為 null，則返回 true；
若兩只有一個為 null，則返回 false。

(2) 其餘情況下返回方法呼叫 x == (y) 的結果。
值得注意的是： == 之類的運算子是在第一個運算元上呼叫的方法。
*/

// void main() {
//   var a = 10;
//   var b = 10;
//   var c = 30;
//   var d = 40;

//   // 定義 e 和 f 且未設定值，預設為 null
//   var e, f;

//   // 相等運算
//   print('a == b : ${a == b}');
//   print('e == f : ${e == f}');
//   print('a == e : ${a == e}');

//   // 不等運算
//   print('a != c : ${a != c}');

//   // 大於運算
//   print('d > c : ${d > c}');

//   // 小於運算
//   print('b < d : ${b < d}');

//   // 大於或等於運算
//   print('a >= b : ${a >= b}');

//   // 小於或等於運算
//   print('b <= c : ${b <= c}');
// }

// 4.3 類型測試運算子
/*
測試運算子可以在執行時期，檢查類型
as -> 類型轉換
is -> 類型判斷，如果物件是指定物件則返回 true
is -> 類型判斷，如果物件不是指定物件則返回 true

運算子 is 檢查的不是物件是否屬於某個類別或其子類別，
而是檢查物件所屬的類別是否實現了某個類別的介面 (直接或間接)。

若物件 obj 實現了類別 T 定義的介面，
obj is T 則返回 true。

obj is Object 則始終返回 true，
因為 Object 是所有類別的父類別。

運算子 as 也是用來檢查物件是否屬於某個類型或其子類別，

區別在於，
如果測試成功，則返回被檢測的物件，
如果測試失敗，則會拋出一個 CastError。
*/

// 定義類 Car
// class Car {
//   String? length;
//   String? color;
// }

// // 定義類 Taxi 繼承類別 Car
// class Taxi extends Car {
//   double? fee;
// }

// void main() {
//   var t = Taxi();
//   (t as Car).color = 'RED';
//   print('變數 t 的引用物件執行時期類型為 ${t.runtimeType}');
//   print('t 的引用物件是類別 Car 的子類別: ${t is Car}');
//   print('t 的引用物件是類別 Taxi 的子類別: ${t is Taxi}');
//   print('t as Car 執行時期類行為 ${(t as Car).runtimeType}');
//   print('t as Taxi 執行時期類行為 ${(t as Taxi).runtimeType}');

// // 運算子的主要使用場景是資料驗證

//   print((t as Car).color);

//   // 上述程式部分實際上是對 as 運算子的濫用，
//   // 因為類型轉換是在執行時期才執行的，
//   // 因此會造成運算資源的消耗
//   // 這裡只是為了演示它的返回值是被檢測物件 t
//   // 因為已經明確知道物件 t 所屬的類別就是 Car 類別的子類別，
//   // 在實際開發中應當避免類似操作
// }

// 4.4 設定運算子

/*
= -> a=b

??= -> a ??= b 等值於: a 等於 null 時 a = b

-= -> a -= b 等於: a = a-b

/= -> a /= b 等於: a = a/b

%= -> a %= b 等於: a = a%b

>>= -> a >>= b 等於: a = a>>b

^= -> a ^= b 等於: a = a^b

+= -> a += b 等於: a = a+b

*= -> a *= b 等於: a = a*b

~/= -> a ~/= b 等於: a = a~/b

<<= -> a <<= b 等於: a = a<<b

&= -> a &= b 等於: a = a&b

|= -> a |= b 等於 a = a|b

可以使用符號 = 為變數設定值，使用 ??= 為值為 null 的變數設定值。
*/
// void main() {
//   // 為變數 a 設定值
//   var a = 12;
//   print('a: $a');

//   var b1 = 10, b2;
//   // b1 已有初值，所以將保持原值
//   b1 ??= 13;

//   // b2 沒有初值所以將被設定值
//   b2 ??= 13;

//   print('b1: $b1, b2: $b2');

//   // 複合設定運算子的使用範例
//   var c = 12, d = 5;
//   print('c %= d: ${c %= d}');
//   print('c: $c');
//   print('c ~/= d: ${c ~/= d}');
// }

// void main() {
//   var a = 10, b = 5;
//   // a >>= b;
//   // print(a>>b);
//   print('a: $a');
//   print('b: $b');
// }

// 4.5 邏輯運算子

/*
邏輯運算子運算後的結果都為布林值。
邏輯與 和 邏輯或 都是先計算左運算元，再計算右運算元。

如果 邏輯與 左運算元計算結果是 假值，則返回假值，無須計算右運算元
如果 邏輯或 左運算元計算結果是 真值，則返回真值，無須計算右運算元

!expr -> 對運算是結果反轉

|| -> 邏輯或

&& -> 邏輯與

*/

// void main() {
//   var c = true, d = false, e = true;
//   // 非運算
//   print('!c: ${!c}');

//   print('!d: ${!d}');

//   // 邏輯或 運算
//   print('c || d: ${c || d}');
//   print('c || e: ${c || e}');

//   // 邏輯與 運算
//   print('c && d: ${c && d}');
//   print('c && e: ${c && e}');
// }

// 4.6 位元運算符號

/*
位元運算符號可以運算數字的各個二進位位元。

一般來說，
可以對整數使用這些位元運算符號和移位運算符號。

& -> 逐位元進行 與 操作

| -> 逐位元進行 或 操作

^ -> 逐位元進行 互斥 操作

~expr -> 逐位元進行 反轉操作

<< -> 逐位元進行 左移 操作

>> -> 逐位元進行 右移 操作

*/

// 下例中使用了兩個十六進位數，他們實際上是先轉為二進位數字，
// 然後進行位元運算。

// void main() {
//   final value = 0x22; // 二進位為: 100010
//   final bitmask = 0x0f; /// 二進位為 1111

//   // 逐位元進行 與 操作
//   print((value & bitmask) == 0x02);

// 暫略...

// }

// 4.7 條件運算式

/*
條件運算式常用在建構一個設定陳述式，
它們也用於替代簡單的 if else 敘述

condition ? expr1 : expr2
若條件為真，則返回 expr1，否則返回 expr2


expr1 ?? expr2
若 expr1 為 null，返回 expr2
否則返回 expr1

*/

// void main() {
//   bool isPublic = true;

//   // 三元條件運算式
//   print('${isPublic ? 'public' : 'private'}');

//   var x, y = 10, z = 20;
//   // 二元條件運算式
//   print('${x ?? y}');
//   print('${y ?? z}');
// }

// 4.8 其他運算子

/*
() -> 代表呼叫的是函數

[] -> 存取 List 特定位置的元素

. -> 存取物件的成員

?. -> 有條件地存取物件的成員，若物件為 null 則返回 null

*/

// 定義類別 Point
// class Point {
//   int x, y;
//   Point(this.x, this.y);
// }

// // 定義頂層函數 printTime
// void printTime() {
//   print(DateTime.now());
// }

// void main() {
//   // 透過使用 () 運算子標示呼叫的是函數
//   printTime();

//   var ls = [1, 2, 3];
//   // 透過 [] 運算子存取 ls 陣列的第一個元素
//   var a = ls[0];

//   var p1 = Point(3, 6);
//   // 透過 . 運算子存取 p1 的成員 x
//   print('${p1.x}');

//   var p2;
//   // 透過 ?. 運算子存取 p2 的成員 x
//   // 因為 p2 沒有成員 x，所以返回 null
//   print('${p2?.x}');
// }

// 第四章完結
